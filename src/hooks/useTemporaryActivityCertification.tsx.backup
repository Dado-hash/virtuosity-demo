import { useState } from 'react';
import { useSupabase } from '@/providers/SupabaseProvider';
import { useToast } from '@/hooks/use-toast';
import { supabase } from '@/lib/supabase';

export const useTemporaryActivityCertification = () => {
  const { user, createBlockchainTransaction } = useSupabase();
  const { toast } = useToast();
  const [certifyingId, setCertifyingId] = useState<string | null>(null);

  const certifyActivityTemporary = async (activityId: string) => {
    if (!user) {
      throw new Error('User not authenticated');
    }

    setCertifyingId(activityId);

    try {
      console.log(`üöÄ Starting temporary blockchain certification for activity ${activityId}`);

      // Get activity details from database first
      const { data: activity, error } = await supabase
        .from('activities')
        .select('*')
        .eq('id', activityId)
        .eq('user_id', user.id)
        .single();

      if (error || !activity) {
        throw new Error('Activity not found');
      }

      if (activity.verified) {
        throw new Error('Activity already certified');
      }

      console.log(`üìù Activity details:`, {
        description: activity.description,
        type: activity.type,
        co2_saved: activity.co2_saved,
        tokens_earned: activity.tokens_earned
      });

      // Show progress toast
      toast({
        title: "üîó Certificazione Temporanea",
        description: "Simulando certificazione blockchain...",
      });

      // Simulate blockchain delay
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Generate a simulated transaction hash
      const simulatedTxHash = `0x${Math.random().toString(16).substr(2, 64)}`;

      console.log(`‚úÖ Simulated blockchain transaction: ${simulatedTxHash}`);

      // Create blockchain transaction record
      await createBlockchainTransaction({
        transaction_hash: simulatedTxHash,
        type: 'activity_certification',
        amount: activity.tokens_earned,
        data: { 
          activityId, 
          co2_saved: activity.co2_saved,
          description: activity.description,
          note: 'Temporary simulation - will be replaced with real blockchain tx'
        },
        status: 'completed'
      });

      // Update activity in database with blockchain hash
      await supabase
        .from('activities')
        .update({ 
          verified: true,
          blockchain_tx_hash: simulatedTxHash,
          updated_at: new Date().toISOString()
        })
        .eq('id', activityId);

      // Update user token balances
      const newPendingTokens = Math.max(0, user.tokens_pending - activity.tokens_earned);
      const newMintedTokens = user.tokens_minted + activity.tokens_earned;
      
      await supabase
        .from('users')
        .update({
          tokens_pending: newPendingTokens,
          tokens_minted: newMintedTokens,
          updated_at: new Date().toISOString()
        })
        .eq('id', user.id);

      console.log(`üéâ Temporary certification complete!`);
      
      toast({
        title: "üéâ Certificazione Completata!",
        description: `Attivit√† certificata temporaneamente. TX: ${simulatedTxHash.slice(0, 10)}...`,
      });

      return simulatedTxHash;

    } catch (error: any) {
      console.error('üí• Error in temporary certification:', error);
      
      let errorMessage = "Errore durante la certificazione temporanea";
      if (error.message) {
        errorMessage = error.message;
      }
      
      toast({
        title: "‚ùå Errore Certificazione",
        description: errorMessage,
        variant: "destructive"
      });
      
      throw error;
    } finally {
      setCertifyingId(null);
    }
  };

  return {
    certifyActivityTemporary,
    certifyingId,
    isConnected: true, // Always true for temporary solution
    userAddress: user?.wallet_address || 'temp-address'
  };
};

import{g as e,a as r,u as o,b as i,c as s,C as n,d as l,s as d,U as h,e as p,f as m,h as k,G as f,W as C,i as U,j as W,k as T,l as S,m as R,n as _,o as j,p as q,q as G,r as Q}from"./privy-provider-BWC5Ur7o.mjs";export{v as Captcha,w as ConnectorManager,E as EthereumWalletConnector,O as LoginModal,H as PrivyClient,P as PrivyProvider,V as VERSION,x as WalletConnector,D as errorIndicatesMaxMfaRetries,F as errorIndicatesMfaTimeout,B as errorIndicatesMfaVerificationFailed,t as getAccessToken,L as useCreateWallet,I as useIdentityToken,N as useImportWallet,J as useLogout,z as useMfa,A as useMfaEnrollment,y as usePrivy,K as useRegisterMfaListener,M as useSolanaWallets}from"./privy-provider-BWC5Ur7o.mjs";import{useCallback as X,useMemo as $,useEffect as Y,useContext as Z,useState as ee,useRef as te}from"react";import{P as re,a as oe}from"./paths-j39vuJt8.mjs";import{u as ie,I as ae}from"./internal-context-De1jxnac.mjs";import{u as se,P as ne,g as le,a as ce,b as ue,c as de}from"./use-sign-with-user-signer-C3vxQSbq.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-CFPTzCLv.mjs";import{F as he}from"./frame-UsDF_L76.mjs";import{zeroAddress as we,getAddress as pe,createWalletClient as ge,http as me,parseSignature as ye}from"viem";import{hashAuthorization as Ae}from"viem/utils";import{getWallet as ke,updateWallet as fe,generateAuthorizationSignature as Ce}from"@privy-io/js-sdk-core";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import"react/jsx-runtime";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@privy-io/ethereum";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ShieldCheckIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"zustand";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/ArrowTopRightOnSquareIcon";import"@heroicons/react/24/solid/DocumentCheckIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"qrcode";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"ofetch";import"@heroicons/react/24/outline";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/outline/CloudArrowUpIcon";import"@heroicons/react/24/outline/NoSymbolIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const Ee=()=>{let{user:t}=se(),{walletProxy:o}=ie();return{recover:X((async i=>{if(!o)throw Error("Wallet proxy is not ready");let a=await e();if(!t||!a)throw new re("User must be logged in before attempting to modify the recovery method.");let{entropyId:s,entropyIdVerifier:n}=r(t);try{await o.recover({entropyId:s,entropyIdVerifier:n,accessToken:a,...i})}catch{throw new re("Unable to recover wallets")}}),[o,t])}},Ie=()=>{let{client:e,setAuthenticated:t,setUser:r}=ie();return $((()=>({init:async()=>{if(!e)throw new re("Must initialize Privy client first.");let t=new he;return e.startAuthFlow(t),await t.init()},login:async({fid:o,message:i,signature:a})=>{if(!e)throw new re("Must initialize Privy client first.");if(!(e.authFlow instanceof he))throw new re("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:i,signature:a,fid:o});let{user:s}=await e.authenticate();if(!s)throw new re("Failed to login with Farcaster V2");return r(s),t(!0),{user:s}}})),[e,r,t])},Ue=e=>{o("login",e);let t=i(),r=s(),{ready:a,user:c}=se(),{initLoginWithHeadlessOAuth:u,loginWithHeadlessOAuth:h,oAuthState:w,setOAuthState:p,isHeadlessOAuthLoading:g}=ie(),m=X((async e=>{try{if(t.enabled&&"success"!==t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);return await u(e.provider,t.token,e.disableSignup)}catch(e){throw p({status:"error",error:e}),e}}),[u,t]),y=X((async()=>{let e=l();try{if(c)return console.warn("Cannot login with OAuth when already logged in"),c;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw p({status:"error",error:e}),e}try{return await h(e)}catch(e){throw p({status:"error",error:e}),e}finally{d()}}),[h]);return Y((()=>{let e=l();a&&r&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&y().catch((()=>{}))}),[a,r]),{initOAuth:m,loading:g,state:w}},We=e=>{let t=i(),{emailOtpState:r,setEmailOtpState:o,initLoginWithEmail:a,loginWithCode:s}=ie();return{sendCode:X((async({email:r,disableSignup:i})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({email:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:X((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await s(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[s,t.status]),state:r}},Te=e=>{let t=i(),{initSignupWithPasskey:r,signupWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:s}=ie();return{signupWithPasskey:X((async()=>{try{let i;if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),i=await t.waitForResult()),await r({captchaToken:i,withPrivyUi:!1});let{user:a,isNewUser:s,wasAlreadyAuthenticated:l,loginAccount:c}=await o();e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:l,loginMethod:"passkey",loginAccount:c})}catch(t){throw s({status:"error",error:t}),e?.onError?.(t.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),t}}),[o,t.status]),state:a}},Se=e=>{let t=i(),{initLoginWithPasskey:r,loginWithPasskey:o,passkeyAuthState:a,setPasskeyAuthState:s}=ie();return{loginWithPasskey:X((async i=>{try{let a;if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),a=await t.waitForResult()),await r({captchaToken:a,withPrivyUi:!1});let{user:s,isNewUser:l,wasAlreadyAuthenticated:c,loginAccount:u}=await o(i);e?.onComplete?.({user:s,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:u})}catch(i){throw s({status:"error",error:i}),e?.onError?.(i.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),i}}),[o,t.status]),state:a}},ve=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:o,setPasskeyAuthState:i}=ie();return{linkWithPasskey:X((async()=>{try{await t();let o=await r();if(!o)throw Error("Error, user not found");let i=o.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:o,linkMethod:"passkey",linkedAccount:i})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:o}},Re=e=>{let t=i(),{smsOtpState:r,setSmsOtpState:o,initLoginWithSms:a,loginWithCode:s}=ie();return{sendCode:X((async({phoneNumber:r,disableSignup:i})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await a({phoneNumber:r,captchaToken:e,disableSignup:i,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[a]),loginWithCode:X((async({code:r})=>{try{if(t.enabled&&"success"!==t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:l}=await s(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[s,t.status]),state:r}},Ne=e=>{let{connectOrCreateWallet:t}=se();return o("connectOrCreateWallet",e),{connectOrCreateWallet:t}},Pe=e=>{let t=i(),{siweState:r,setSiweState:o,linkWithSiwe:a,generateSiweMessage:s}=ie();return{generateSiweMessage:X((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await s({address:t,chainId:r}).then((e=>e))}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[s]),linkWithSiwe:X((async({signature:r,message:i,chainId:s,walletClientType:l,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);let{user:o,linkedAccount:u}=await a({message:i,signature:r,chainId:s,walletClientType:l,connectorType:c});u&&e?.onSuccess?.({user:o,linkMethod:"siwe",linkedAccount:u})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[a,t.status]),state:r}},be=e=>{let t=i(),{siweState:r,setSiweState:o,client:a,generateSiweMessage:s,loginWithSiwe:l}=ie();return{generateSiweNonce:X((async r=>{try{let e;if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),o({status:"generating-message"});let i=await a.generateSiweNonce({address:r?.address,captchaToken:e});return o({status:"awaiting-signature"}),i}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[a,t]),generateSiweMessage:X((async({address:t,chainId:r})=>{try{return await s({address:t,chainId:r})}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),t}}),[s]),loginWithSiwe:X((async({message:r,signature:i,disableSignup:a})=>{try{let o;if(t.enabled&&"error"===t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),o=await t.waitForResult());let s=await l({message:r,signature:i,captchaToken:o,disableSignup:a});return e?.onComplete?.({user:s,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),s}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),r}}),[l,t.status]),state:r}};function Oe(){let{signTransaction:e}=Z(ne);return{signTransaction:e}}function _e(e){let{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:s,linkTwitter:n,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkTelegram:g,linkFarcaster:m,linkPasskey:y}=Z(ne);return o("linkAccount",e),{linkEmail:t,linkPhone:r,linkWallet:i,linkGoogle:a,linkApple:s,linkTwitter:n,linkDiscord:l,linkGithub:c,linkLinkedIn:u,linkTiktok:d,linkLine:h,linkSpotify:w,linkInstagram:p,linkFarcaster:m,linkTelegram:g,linkPasskey:y}}function Me(e){let{updateEmail:t,updatePhone:r}=Z(ne);return o("update",e),{updateEmail:t,updatePhone:r}}const Fe=e=>{let{user:t}=se(),{loginWithCode:r,emailOtpState:o,setEmailOtpState:i,client:a,inProgressAuthFlowRef:s,inProgressLoginOrLinkMethodRef:n}=ie();return{state:o,sendCode:X((async({newEmailAddress:r})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");let e=new h(t.email.address,r);a.startAuthFlow(e),await e.sendCodeEmail({withPrivyUi:!1})}catch(r){i({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email]),verifyCode:X((async({code:o})=>{try{if(!t?.email)throw Error("User is required to have an email address to update it.");s.current="update",n.current="email";let{user:i,linkedAccount:a}=await r(o);return e?.onSuccess?.({user:i,updateMethod:"email",updatedAccount:a}),{user:i}}catch(o){i({status:"error",error:o}),e?.onError?.(o.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[t?.email])}},Le=()=>{let{connectCoinbaseSmartWallet:e}=ie();return{connectCoinbaseSmartWallet:e}},He=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:t,signMessageWithCrossAppWallet:r,signTypedDataWithCrossAppWallet:o,sendTransactionWithCrossAppWallet:i}=se();return{loginWithCrossAppAccount:({appId:t})=>e({appId:t,action:"login"}),linkCrossAppAccount:({appId:t})=>e({appId:t,action:"link"}),unlinkCrossAppAccount:t,signMessage:r,signTypedData:o,sendTransaction:i}};function De(e){let{sendTransaction:t}=Z(ne);return o("sendTransaction",e),{sendTransaction:t}}function xe(e){let{setWalletPassword:t}=Z(ne);return o("setWalletPassword",e),{setWalletPassword:t}}function Ke(){let e=p(),{getAccessToken:t}=se(),r=m(),{client:o,setUser:i,setAuthenticated:a,setIsNewUser:s,initializeWalletProxy:n}=ie(),{create:l}=k();return{createGuestAccount:async()=>{if(!e.id||!o)throw Error("SDK not yet ready");o.startAuthFlow(new f(e.id));try{let c=await o.authenticate(),u=c.user,d=c.isNewUser??!1;if(!u)throw new re("Unable to authenticate guest account");let h=await t(),w=await n(C);if(h&&w)try{let t=U(u,e.embeddedWallets.ethereum.createOnLogin),r=W(u,e.embeddedWallets.solana.createOnLogin);t&&r?(u=(await l({chainType:"ethereum",latestUser:u})).user,u=(await l({chainType:"solana",latestUser:u})).user):r?u=(await l({chainType:"solana",latestUser:u})).user:t?u=(await l({chainType:"ethereum",latestUser:u})).user:i(u)}catch(e){i(u),console.warn("Unable to create embedded wallet for guest account")}return s(d),a(!0),r("login","onComplete",{user:u,isNewUser:d,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),u}catch(e){throw r("login","onError",e.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),e}}}}function ze(e){let{setWalletRecovery:t}=Z(ne);return o("setWalletRecovery",e),{setWalletRecovery:t}}function je(e){let{signMessage:t}=Z(ne);return o("signMessage",e),{signMessage:t}}const qe=()=>{let{ready:e,wallets:t}=T(),{user:r}=se(),{rpcConfig:o,chains:i,appId:a}=ie();return{signAuthorization:X((async(s,n)=>{let l;if(!r)throw Error("User must be authenticated before signing with a Privy wallet");if(!e)throw Error("Wallets are not ready");let c=n?.address??le(r)?.address??we,u=t.find((e=>pe(e.address)===pe(c)));if(!u)throw Error("Signing wallet not found.");let d=s.chainId??Number(u.chainId.split(":")[1]);if(0===d)l={chainId:0,address:s.contractAddress,nonce:s.nonce??0};else{let e=i.find((e=>e.id===d));if(!e)throw Error("Error, chain not configured in PrivyProvider config");let t=ge({account:c,chain:e,transport:me(S(e,o,a))});l=await t.prepareAuthorization({...s})}let h=await u.getEthereumProvider(),w=await h.request({method:"secp256k1_sign",params:[Ae(l)]});return{...l,...ye(w)}}),[e,t,r,i])}},Ve=qe;function Ge(e){let{signTypedData:t}=Z(ne);return o("signTypedData",e),{signTypedData:t}}const Be=()=>{let{isModalOpen:e}=Z(ne);return{isOpen:e}};function Je(e){let{getAccessToken:t}=Z(ne);return o("accessToken",e),{getAccessToken:t}}function Qe(e){let{authenticated:t,user:r}=se(),{initLoginWithOAuth:i}=ie(),a=m();return o("oAuthAuthorization",e),{reauthorize:e=>Xe(t,r,i,a,e.provider)}}let Xe=async(e,t,r,o,i)=>{if(!e)throw o("linkAccount","onError",oe.MUST_BE_AUTHENTICATED,{linkMethod:i}),new re("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(i))))throw new re(`OAuth account of type ${i} not linked to the account.`);await r(i)};function $e(e){let{client:t}=ie(),[r,o]=ee({status:"initial"});return{linkWithCustomJwt:X((async r=>{try{o({status:"initial"}),t.startAuthFlow(new R(r)),o({status:"loading"});let{user:i}=await t.link();if(!i)throw Error("Error, user not found");let a=i.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return o({status:"done"}),e?.onSuccess?.({user:i,linkMethod:"custom",linkedAccount:a}),{user:i}}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||oe.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[t.startAuthFlow,t.link]),state:r}}const Ye=e=>{let t=_();return o("customAuth",e),{status:t}};function Ze({isAuthenticated:e,isLoading:t,...r}){let o=te();Y((()=>{t||o.current?.()}),[e,t]);let i=X((e=>(o.current=e,()=>{o.current=void 0})),[]);return j({...r,subscribe:i})}function et(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}=se();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:t,requestFarcasterSignerFromWarpcast:r}}const tt=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=ie();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},rt=()=>{let{addSessionSignersInternal:e,removeSessionSignersInternal:t}=(()=>{let{getAccessToken:e,user:t}=se(),r=ie(),{signWithUserSigner:o}=ce(),i=async({wallet:i,additional_signers:a})=>{let s=await e();if(!t||!s)throw new re("User must be authenticated and have an embedded wallet to delegate actions.");if(!i.id)throw new re("Wallet to add signers to must have ID on server");if(!r.walletProxy)throw new re("Wallet proxy not initialized.");await fe(r.privy,{wallet_id:i.id},o,{additional_signers:a})};return{addSessionSignersInternal:async({address:o,signers:a})=>{let s=await e();if(!t||!s)throw new re("User must be authenticated and have an embedded wallet to add a session signer.");let n=r.walletProxy??await r.initializeWalletProxy(15e3);if(!n)throw new re("Wallet proxy not initialized.");let l=ue(t,o);if(!l)throw new re("Address to add signers too is not associated with current user.");if(de(l)){if(0===a.length)throw new re("Must specify at least one signer to add.");let e=[...(await ke(r.privy,{wallet_id:l.id})).additional_signers,...q(a)];await i({wallet:l,additional_signers:e})}else{if(l.delegated)return{user:t};if(a.length>0)throw new re("addSessionSigners is only supported for TEE execution and this app uses On-device execution. Use the useHeadlessDelegatedActions hook to manage server side access on behalf of your users. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let e=G({address:o,user:t}),i=Q({address:o,user:t});await r.recoverEmbeddedWallet({address:o}),await n.createDelegatedAction({accessToken:s,rootWallet:i,delegatedWallets:[e]})}let c=await r.refreshSessionAndUser();if(!c)throw Error("Could not refresh user");return{user:c}},removeSessionSignersInternal:async({address:o})=>{let a=await e();if(!t||!a)throw new re("User must be authenticated and have an embedded wallet to delegate actions.");if(!(r.walletProxy??await r.initializeWalletProxy(15e3)))throw new re("Wallet proxy not initialized.");let s=ue(t,o);if(!s)throw new re("Address to remove signers from is not associated with current user.");de(s)?await i({wallet:s,additional_signers:[]}):await r.client.revokeDelegatedWallet();let n=await r.refreshSessionAndUser();if(!n)throw Error("Could not refresh user");return{user:n}}}})();return{addSessionSigners:async({address:t,signers:r})=>e({address:t,signers:r}),removeSessionSigners:async({address:e})=>t({address:e})}},ot=()=>{let{signWithUserSigner:e}=ce();return $((()=>({async generateAuthorizationSignature(t){let{signature:r}=await Ce(e,t);return{signature:r}}})),[e])},it=()=>{let{setUser:e,client:t}=Z(ae),{user:r}=Z(ne);return{user:r,refreshUser:X((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},at=e=>{let t=i(),{initLoginWithTelegram:r,loginWithTelegram:o,telegramAuthState:a,setTelegramAuthState:s}=ie();return{login:X((async i=>{try{if(t.enabled&&"success"!==t.status)throw new n(t.error,null,oe.CAPTCHA_FAILURE);await r(t.token,i?.disableSignup);let{user:a,isNewUser:s,loginAccount:l,wasAlreadyAuthenticated:c}=await o({intent:"login"});e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:l})}catch(i){throw s({status:"error",error:i}),e?.onError?.(i.privyErrorCode||oe.UNKNOWN_AUTH_ERROR),i}}),[r,o,t]),state:a}},st=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=ie();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}};export{ot as useAuthorizationSignature,Le as useConnectCoinbaseSmartWallet,Ne as useConnectOrCreateWallet,He as useCrossAppAccounts,Ye as useCustomAuth,tt as useDelegatedActions,et as useFarcasterSigner,Ke as useGuestAccounts,st as useHeadlessDelegatedActions,_e as useLinkAccount,$e as useLinkJwtAccount,ve as useLinkWithPasskey,Pe as useLinkWithSiwe,We as useLoginWithEmail,Ie as useLoginWithFarcasterV2,Ue as useLoginWithOAuth,Se as useLoginWithPasskey,be as useLoginWithSiwe,Re as useLoginWithSms,at as useLoginWithTelegram,Be as useModalStatus,Qe as useOAuthTokens,Ee as useRecoverEmbeddedWallet,De as useSendTransaction,rt as useSessionSigners,xe as useSetWalletPassword,ze as useSetWalletRecovery,qe as useSign7702Authorization,Ve as useSignAuthorization,je as useSignMessage,Oe as useSignTransaction,Ge as useSignTypedData,Te as useSignupWithPasskey,Ze as useSubscribeToJwtAuthWithFlag,j as useSyncJwtBasedAuthState,Je as useToken,Me as useUpdateAccount,Fe as useUpdateEmail,it as useUser,T as useWallets};

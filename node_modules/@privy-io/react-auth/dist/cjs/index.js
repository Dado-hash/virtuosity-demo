"use strict";var e=require("./privy-provider-Ds0Q6p6C.js"),r=require("react"),t=require("./paths-CdRs2pll.js"),i=require("./internal-context-vhWXhsPy.js"),o=require("./use-sign-with-user-signer-CpEHKe74.js"),s=require("./useActiveWallet-exwS4YR8.js"),n=require("./frame-B38H7ILa.js"),a=require("viem"),l=require("viem/utils"),u=require("@privy-io/js-sdk-core"),c=require("./getEmbeddedConnectedWallet-DTU4T9TJ.js");require("react/jsx-runtime"),require("mipd"),require("react-device-detect"),require("uuid"),require("jose"),require("eventemitter3"),require("@coinbase/wallet-sdk"),require("@privy-io/ethereum"),require("@marsidev/react-turnstile"),require("styled-components"),require("tinycolor2"),require("@heroicons/react/24/outline/DevicePhoneMobileIcon"),require("@heroicons/react/24/outline/FingerPrintIcon"),require("@heroicons/react/24/outline/PhoneIcon"),require("@heroicons/react/24/outline/ShieldCheckIcon"),require("@heroicons/react/24/outline/ArrowLeftIcon"),require("@heroicons/react/24/outline/ArrowRightIcon"),require("@heroicons/react/24/outline/QuestionMarkCircleIcon"),require("@heroicons/react/24/outline/XMarkIcon"),require("@heroicons/react/24/outline/CalendarIcon"),require("@heroicons/react/24/outline/ExclamationTriangleIcon"),require("@heroicons/react/24/outline/ChevronDownIcon"),require("@headlessui/react"),require("@walletconnect/ethereum-provider"),require("zustand"),require("fast-password-entropy"),require("secure-password-utilities"),require("secure-password-utilities/wordlists"),require("@heroicons/react/24/outline/UserCircleIcon"),require("@heroicons/react/24/outline/EnvelopeIcon"),require("@heroicons/react/20/solid/CheckIcon"),require("@heroicons/react/24/outline/WalletIcon"),require("@heroicons/react/24/outline/CheckIcon"),require("@heroicons/react/24/outline/Square2StackIcon"),require("@heroicons/react/24/outline/ExclamationCircleIcon"),require("@heroicons/react/24/outline/ArrowTopRightOnSquareIcon"),require("@heroicons/react/24/solid/DocumentCheckIcon"),require("@heroicons/react/24/solid/XCircleIcon"),require("@heroicons/react/24/solid/CheckCircleIcon"),require("qrcode"),require("@heroicons/react/24/solid/ArrowsRightLeftIcon"),require("@heroicons/react/24/outline/ChevronRightIcon"),require("@heroicons/react/24/outline/LockClosedIcon"),require("@heroicons/react/24/outline/PencilSquareIcon"),require("@heroicons/react/24/outline/ArrowPathIcon"),require("@heroicons/react/24/outline/EyeIcon"),require("@heroicons/react/24/outline/EyeSlashIcon"),require("@heroicons/react/24/outline/KeyIcon"),require("@heroicons/react/24/outline/ArrowDownTrayIcon"),require("@heroicons/react/24/outline/ClipboardDocumentCheckIcon"),require("@heroicons/react/24/outline/DocumentDuplicateIcon"),require("@heroicons/react/24/solid/LockClosedIcon"),require("@heroicons/react/24/outline/CheckCircleIcon"),require("@heroicons/react/24/outline/InformationCircleIcon"),require("@heroicons/react/24/outline/CreditCardIcon"),require("@heroicons/react/24/outline/QrCodeIcon"),require("@heroicons/react/24/outline/GlobeAltIcon"),require("ofetch"),require("@heroicons/react/24/outline"),require("@heroicons/react/24/outline/ClipboardDocumentIcon"),require("@heroicons/react/24/outline/CloudArrowUpIcon"),require("@heroicons/react/24/outline/NoSymbolIcon"),require("@heroicons/react/24/outline/ClockIcon"),require("@heroicons/react/24/outline/TrashIcon"),require("@heroicons/react/24/solid/CheckBadgeIcon"),require("@heroicons/react/24/solid/IdentificationIcon"),require("@heroicons/react/24/outline/MinusCircleIcon"),require("@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon"),require("@heroicons/react/24/solid/ShieldCheckIcon"),require("js-cookie");const d=()=>{let{ready:t,wallets:s}=e.useWallets(),{user:n}=o.usePrivyContext(),{rpcConfig:u,chains:c,appId:d}=i.usePrivyInternal();return{signAuthorization:r.useCallback((async(r,i)=>{let h;if(!n)throw Error("User must be authenticated before signing with a Privy wallet");if(!t)throw Error("Wallets are not ready");let y=i?.address??o.getPrivyEthereumWallet(n)?.address??a.zeroAddress,w=s.find((e=>a.getAddress(e.address)===a.getAddress(y)));if(!w)throw Error("Signing wallet not found.");let p=r.chainId??Number(w.chainId.split(":")[1]);if(0===p)h={chainId:0,address:r.contractAddress,nonce:r.nonce??0};else{let t=c.find((e=>e.id===p));if(!t)throw Error("Error, chain not configured in PrivyProvider config");let i=a.createWalletClient({account:y,chain:t,transport:a.http(e.getJsonRpcEndpointFromChain(t,u,d))});h=await i.prepareAuthorization({...r})}let g=await w.getEthereumProvider(),C=await g.request({method:"secp256k1_sign",params:[l.hashAuthorization(h)]});return{...h,...a.parseSignature(C)}}),[t,s,n,c])}},h=d;let y=async(e,r,i,o,s)=>{if(!e)throw o("linkAccount","onError",t.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:s}),new t.PrivyClientError("User must be authenticated before linking an account.");if(!r?.linkedAccounts.some((e=>e.type.includes(s))))throw new t.PrivyClientError(`OAuth account of type ${s} not linked to the account.`);await i(s)};exports.Captcha=e.Captcha,exports.ConnectorManager=e.ConnectorManager,exports.EthereumWalletConnector=e.EthereumWalletConnector,exports.LoginModal=e.LoginModal,exports.PrivyClient=e.PrivyClient,exports.PrivyProvider=e.PrivyProvider,exports.VERSION=e.VERSION,exports.WalletConnector=e.WalletConnector,exports.errorIndicatesMaxMfaRetries=e.errorIndicatesMaxMfaRetries,exports.errorIndicatesMfaTimeout=e.errorIndicatesMfaTimeout,exports.errorIndicatesMfaVerificationFailed=e.errorIndicatesMfaVerificationFailed,exports.getAccessToken=e.getCustomerAccessToken,exports.useCreateWallet=e.useCreateWallet,exports.useIdentityToken=e.useIdentityToken,exports.useImportWallet=e.useImportWallet,exports.useLogout=e.useLogout,exports.useMfa=e.useMfa,exports.useMfaEnrollment=e.useMfaEnrollment,exports.usePrivy=e.usePrivy,exports.useRegisterMfaListener=e.useRegisterMfaListener,exports.useSolanaWallets=e.useSolanaWallets,exports.useSyncJwtBasedAuthState=e.useSyncJwtBasedAuthState,exports.useWallets=e.useWallets,exports.useActiveWallet=s.useActiveWallet,exports.useConnectWallet=s.useConnectWallet,exports.useFundWallet=s.useFundWallet,exports.useLogin=s.useLogin,Object.defineProperty(exports,"SUPPORTED_CHAINS",{enumerable:!0,get:function(){return u.DEFAULT_SUPPORTED_CHAINS}}),Object.defineProperty(exports,"addPrivyRpcToChain",{enumerable:!0,get:function(){return u.addPrivyRpcToChain}}),Object.defineProperty(exports,"addRpcUrlOverrideToChain",{enumerable:!0,get:function(){return u.addRpcUrlOverrideToChain}}),exports.getEmbeddedConnectedWallet=c.getEmbeddedConnectedWallet,exports.useAuthorizationSignature=()=>{let{signWithUserSigner:e}=o.useSignWithUserSigner();return r.useMemo((()=>({async generateAuthorizationSignature(r){let{signature:t}=await u.generateAuthorizationSignature(e,r);return{signature:t}}})),[e])},exports.useConnectCoinbaseSmartWallet=()=>{let{connectCoinbaseSmartWallet:e}=i.usePrivyInternal();return{connectCoinbaseSmartWallet:e}},exports.useConnectOrCreateWallet=r=>{let{connectOrCreateWallet:t}=o.usePrivyContext();return e.usePrivyEventSubscription("connectOrCreateWallet",r),{connectOrCreateWallet:t}},exports.useCrossAppAccounts=()=>{let{startCrossAppAuthFlow:e,unlinkCrossAppAccount:r,signMessageWithCrossAppWallet:t,signTypedDataWithCrossAppWallet:i,sendTransactionWithCrossAppWallet:s}=o.usePrivyContext();return{loginWithCrossAppAccount:({appId:r})=>e({appId:r,action:"login"}),linkCrossAppAccount:({appId:r})=>e({appId:r,action:"link"}),unlinkCrossAppAccount:r,signMessage:t,signTypedData:i,sendTransaction:s}},exports.useCustomAuth=r=>{let t=e.useJwtAuthFlowState();return e.usePrivyEventSubscription("customAuth",r),{status:t}},exports.useDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=i.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},exports.useFarcasterSigner=function(){let{getFarcasterSignerPublicKey:e,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:t}=o.usePrivyContext();return{getFarcasterSignerPublicKey:e,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:t}},exports.useGuestAccounts=function(){let r=e.useAppConfig(),{getAccessToken:s}=o.usePrivyContext(),n=e.useEmitPrivyEvent(),{client:a,setUser:l,setAuthenticated:u,setIsNewUser:c,initializeWalletProxy:d}=i.usePrivyInternal(),{create:h}=e.useCreateWalletInternal();return{createGuestAccount:async()=>{if(!r.id||!a)throw Error("SDK not yet ready");a.startAuthFlow(new e.GuestFlow(r.id));try{let i=await a.authenticate(),o=i.user,y=i.isNewUser??!1;if(!o)throw new t.PrivyClientError("Unable to authenticate guest account");let w=await s(),p=await d(e.WALLET_PROXY_TIMEOUT);if(w&&p)try{let t=e.shouldCreateEmbeddedEthWallet(o,r.embeddedWallets.ethereum.createOnLogin),i=e.shouldCreateEmbeddedSolWallet(o,r.embeddedWallets.solana.createOnLogin);t&&i?(o=(await h({chainType:"ethereum",latestUser:o})).user,o=(await h({chainType:"solana",latestUser:o})).user):i?o=(await h({chainType:"solana",latestUser:o})).user:t?o=(await h({chainType:"ethereum",latestUser:o})).user:l(o)}catch(e){l(o),console.warn("Unable to create embedded wallet for guest account")}return c(y),u(!0),n("login","onComplete",{user:o,isNewUser:y,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),o}catch(e){throw n("login","onError",e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}}},exports.useHeadlessDelegatedActions=()=>{let{revokeDelegatedWallets:e,delegateWallet:r}=i.usePrivyInternal();return{delegateWallet:async({address:e,chainType:t})=>await r({address:e,chainType:t,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}},exports.useLinkAccount=function(t){let{linkEmail:i,linkPhone:s,linkWallet:n,linkGoogle:a,linkApple:l,linkTwitter:u,linkDiscord:c,linkGithub:d,linkLinkedIn:h,linkTiktok:y,linkLine:w,linkSpotify:p,linkInstagram:g,linkTelegram:C,linkFarcaster:A,linkPasskey:v}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("linkAccount",t),{linkEmail:i,linkPhone:s,linkWallet:n,linkGoogle:a,linkApple:l,linkTwitter:u,linkDiscord:c,linkGithub:d,linkLinkedIn:h,linkTiktok:y,linkLine:w,linkSpotify:p,linkInstagram:g,linkFarcaster:A,linkTelegram:C,linkPasskey:v}},exports.useLinkJwtAccount=function(o){let{client:s}=i.usePrivyInternal(),[n,a]=r.useState({status:"initial"});return{linkWithCustomJwt:r.useCallback((async r=>{try{a({status:"initial"}),s.startAuthFlow(new e.CustomJwtAccountFlow(r)),a({status:"loading"});let{user:t}=await s.link();if(!t)throw Error("Error, user not found");let i=t.linkedAccounts.filter((e=>"custom_auth"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime())).at(0);return a({status:"done"}),o?.onSuccess?.({user:t,linkMethod:"custom",linkedAccount:i}),{user:t}}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"custom"}),r}}),[s.startAuthFlow,s.link]),state:n}},exports.useLinkWithPasskey=e=>{let{initLinkWithPasskey:o,linkWithPasskey:s,passkeyAuthState:n,setPasskeyAuthState:a}=i.usePrivyInternal();return{linkWithPasskey:r.useCallback((async()=>{try{await o();let r=await s();if(!r)throw Error("Error, user not found");let t=r.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,r)=>r.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:r,linkMethod:"passkey",linkedAccount:t})}catch(r){throw a({status:"error",error:r}),e?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),r}}),[s]),state:n}},exports.useLinkWithSiwe=o=>{let s=e.useCaptcha(),{siweState:n,setSiweState:a,linkWithSiwe:l,generateSiweMessage:u}=i.usePrivyInternal();return{generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{if(!e||!r)throw Error("wallet address and chainId required to generate nonce");return await u({address:e,chainId:r}).then((e=>e))}catch(e){throw a({status:"error",error:e}),o?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),e}}),[u]),linkWithSiwe:r.useCallback((async({signature:r,message:i,chainId:n,walletClientType:u,connectorType:c})=>{try{if(s.enabled&&"success"!==s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:a,linkedAccount:d}=await l({message:i,signature:r,chainId:n,walletClientType:u,connectorType:c});d&&o?.onSuccess?.({user:a,linkMethod:"siwe",linkedAccount:d})}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[l,s.status]),state:n}},exports.useLoginWithEmail=o=>{let s=e.useCaptcha(),{emailOtpState:n,setEmailOtpState:a,initLoginWithEmail:l,loginWithCode:u}=i.usePrivyInternal();return{sendCode:r.useCallback((async({email:r,disableSignup:i})=>{try{let o;if(!r)throw Error("Email required to send OTP code");if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return s.enabled&&"success"!==s.status&&(s.execute(),o=await s.waitForResult()),await l({email:r,captchaToken:o,disableSignup:i,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l]),loginWithCode:r.useCallback((async({code:r})=>{try{if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:i,isNewUser:n,wasAlreadyAuthenticated:a,linkedAccount:l}=await u(r);o?.onComplete?.({user:i,isNewUser:n,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:l})}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,s.status]),state:n}},exports.useLoginWithFarcasterV2=()=>{let{client:e,setAuthenticated:o,setUser:s}=i.usePrivyInternal();return r.useMemo((()=>({init:async()=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");let r=new n.FarcasterFramesFlow;return e.startAuthFlow(r),await r.init()},login:async({fid:r,message:i,signature:a})=>{if(!e)throw new t.PrivyClientError("Must initialize Privy client first.");if(!(e.authFlow instanceof n.FarcasterFramesFlow))throw new t.PrivyClientError("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:i,signature:a,fid:r});let{user:l}=await e.authenticate();if(!l)throw new t.PrivyClientError("Failed to login with Farcaster V2");return s(l),o(!0),{user:l}}})),[e,s,o])},exports.useLoginWithOAuth=s=>{e.usePrivyEventSubscription("login",s);let n=e.useCaptcha(),a=e.useIsServerConfigLoaded(),{ready:l,user:u}=o.usePrivyContext(),{initLoginWithHeadlessOAuth:c,loginWithHeadlessOAuth:d,oAuthState:h,setOAuthState:y,isHeadlessOAuthLoading:w}=i.usePrivyInternal(),p=r.useCallback((async r=>{try{if(n.enabled&&"success"!==n.status)throw new e.CaptchaError(n.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return await c(r.provider,n.token,r.disableSignup)}catch(r){throw y({status:"error",error:r}),r}}),[c,n]),g=r.useCallback((async()=>{let r=e.detectCompletingOAuthFlow();try{if(u)return console.warn("Cannot login with OAuth when already logged in"),u;if(!r.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(r.popupFlow)return}catch(r){throw y({status:"error",error:r}),r}try{return await d(r)}catch(r){throw y({status:"error",error:r}),r}finally{e.stripUrlOAuthParamsAndRemoveStateCode()}}),[d]);return r.useEffect((()=>{let r=e.detectCompletingOAuthFlow();l&&a&&r.inProgress&&!r.withPrivyUi&&!r.popupFlow&&g().catch((()=>{}))}),[l,a]),{initOAuth:p,loading:w,state:h}},exports.useLoginWithPasskey=o=>{let s=e.useCaptcha(),{initLoginWithPasskey:n,loginWithPasskey:a,passkeyAuthState:l,setPasskeyAuthState:u}=i.usePrivyInternal();return{loginWithPasskey:r.useCallback((async r=>{try{let i;if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);s.enabled&&"success"!==s.status&&(s.execute(),i=await s.waitForResult()),await n({captchaToken:i,withPrivyUi:!1});let{user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginAccount:d}=await a(r);o?.onComplete?.({user:l,isNewUser:u,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:d})}catch(r){throw u({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[a,s.status]),state:l}},exports.useLoginWithSiwe=o=>{let s=e.useCaptcha(),{siweState:n,setSiweState:a,client:l,generateSiweMessage:u,loginWithSiwe:c}=i.usePrivyInternal();return{generateSiweNonce:r.useCallback((async r=>{try{let i;if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);s.enabled&&"success"!==s.status&&(s.execute(),i=await s.waitForResult()),a({status:"generating-message"});let o=await l.generateSiweNonce({address:r?.address,captchaToken:i});return a({status:"awaiting-signature"}),o}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l,s]),generateSiweMessage:r.useCallback((async({address:e,chainId:r})=>{try{return await u({address:e,chainId:r})}catch(e){throw a({status:"error",error:e}),o?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[u]),loginWithSiwe:r.useCallback((async({message:r,signature:i,disableSignup:n})=>{try{let a;if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);s.enabled&&"success"!==s.status&&(s.execute(),a=await s.waitForResult());let l=await c({message:r,signature:i,captchaToken:a,disableSignup:n});return o?.onComplete?.({user:l,isNewUser:!1,wasAlreadyAuthenticated:!1,loginMethod:"siwe",loginAccount:null}),l}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[c,s.status]),state:n}},exports.useLoginWithSms=o=>{let s=e.useCaptcha(),{smsOtpState:n,setSmsOtpState:a,initLoginWithSms:l,loginWithCode:u}=i.usePrivyInternal();return{sendCode:r.useCallback((async({phoneNumber:r,disableSignup:i})=>{try{let o;if(!r)throw Error("SMS required to send OTP code");if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);return s.enabled&&"success"!==s.status&&(s.execute(),o=await s.waitForResult()),await l({phoneNumber:r,captchaToken:o,disableSignup:i,withPrivyUi:!1})}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[l]),loginWithCode:r.useCallback((async({code:r})=>{try{if(s.enabled&&"success"!==s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);let{user:i,isNewUser:n,wasAlreadyAuthenticated:a,linkedAccount:l}=await u(r);o?.onComplete?.({user:i,isNewUser:n,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:l})}catch(r){throw a({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[u,s.status]),state:n}},exports.useLoginWithTelegram=o=>{let s=e.useCaptcha(),{initLoginWithTelegram:n,loginWithTelegram:a,telegramAuthState:l,setTelegramAuthState:u}=i.usePrivyInternal();return{login:r.useCallback((async r=>{try{if(s.enabled&&"success"!==s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);await n(s.token,r?.disableSignup);let{user:i,isNewUser:l,loginAccount:u,wasAlreadyAuthenticated:c}=await a({intent:"login"});o?.onComplete?.({user:i,isNewUser:l,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:u})}catch(r){throw u({status:"error",error:r}),o?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),r}}),[n,a,s]),state:l}},exports.useModalStatus=()=>{let{isModalOpen:e}=r.useContext(o.PrivyContext);return{isOpen:e}},exports.useOAuthTokens=function(r){let{authenticated:t,user:s}=o.usePrivyContext(),{initLoginWithOAuth:n}=i.usePrivyInternal(),a=e.useEmitPrivyEvent();return e.usePrivyEventSubscription("oAuthAuthorization",r),{reauthorize:e=>y(t,s,n,a,e.provider)}},exports.useRecoverEmbeddedWallet=()=>{let{user:s}=o.usePrivyContext(),{walletProxy:n}=i.usePrivyInternal();return{recover:r.useCallback((async r=>{if(!n)throw Error("Wallet proxy is not ready");let i=await e.getAccessToken();if(!s||!i)throw new t.PrivyClientError("User must be logged in before attempting to modify the recovery method.");let{entropyId:o,entropyIdVerifier:a}=e.getEntropyDetailsForUser(s);try{await n.recover({entropyId:o,entropyIdVerifier:a,accessToken:i,...r})}catch{throw new t.PrivyClientError("Unable to recover wallets")}}),[n,s])}},exports.useSendTransaction=function(t){let{sendTransaction:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("sendTransaction",t),{sendTransaction:i}},exports.useSessionSigners=()=>{let{addSessionSignersInternal:r,removeSessionSignersInternal:s}=(()=>{let{getAccessToken:r,user:s}=o.usePrivyContext(),n=i.usePrivyInternal(),{signWithUserSigner:a}=o.useSignWithUserSigner(),l=async({wallet:e,additional_signers:i})=>{let o=await r();if(!s||!o)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!e.id)throw new t.PrivyClientError("Wallet to add signers to must have ID on server");if(!n.walletProxy)throw new t.PrivyClientError("Wallet proxy not initialized.");await u.updateWallet(n.privy,{wallet_id:e.id},a,{additional_signers:i})};return{addSessionSignersInternal:async({address:i,signers:a})=>{let c=await r();if(!s||!c)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to add a session signer.");let d=n.walletProxy??await n.initializeWalletProxy(15e3);if(!d)throw new t.PrivyClientError("Wallet proxy not initialized.");let h=o.getPrivyWalletWithAddress(s,i);if(!h)throw new t.PrivyClientError("Address to add signers too is not associated with current user.");if(o.getIsUnifiedWallet(h)){if(0===a.length)throw new t.PrivyClientError("Must specify at least one signer to add.");let r=[...(await u.getWallet(n.privy,{wallet_id:h.id})).additional_signers,...e.parseAdditionalSigners(a)];await l({wallet:h,additional_signers:r})}else{if(h.delegated)return{user:s};if(a.length>0)throw new t.PrivyClientError("addSessionSigners is only supported for TEE execution and this app uses On-device execution. Use the useHeadlessDelegatedActions hook to manage server side access on behalf of your users. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let r=e.getDelegatedWalletsData({address:i,user:s}),o=e.getRootWalletDataForDelegation({address:i,user:s});await n.recoverEmbeddedWallet({address:i}),await d.createDelegatedAction({accessToken:c,rootWallet:o,delegatedWallets:[r]})}let y=await n.refreshSessionAndUser();if(!y)throw Error("Could not refresh user");return{user:y}},removeSessionSignersInternal:async({address:e})=>{let i=await r();if(!s||!i)throw new t.PrivyClientError("User must be authenticated and have an embedded wallet to delegate actions.");if(!(n.walletProxy??await n.initializeWalletProxy(15e3)))throw new t.PrivyClientError("Wallet proxy not initialized.");let a=o.getPrivyWalletWithAddress(s,e);if(!a)throw new t.PrivyClientError("Address to remove signers from is not associated with current user.");o.getIsUnifiedWallet(a)?await l({wallet:a,additional_signers:[]}):await n.client.revokeDelegatedWallet();let u=await n.refreshSessionAndUser();if(!u)throw Error("Could not refresh user");return{user:u}}}})();return{addSessionSigners:async({address:e,signers:t})=>r({address:e,signers:t}),removeSessionSigners:async({address:e})=>s({address:e})}},exports.useSetWalletPassword=function(t){let{setWalletPassword:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("setWalletPassword",t),{setWalletPassword:i}},exports.useSetWalletRecovery=function(t){let{setWalletRecovery:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("setWalletRecovery",t),{setWalletRecovery:i}},exports.useSign7702Authorization=d,exports.useSignAuthorization=h,exports.useSignMessage=function(t){let{signMessage:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("signMessage",t),{signMessage:i}},exports.useSignTransaction=function(){let{signTransaction:e}=r.useContext(o.PrivyContext);return{signTransaction:e}},exports.useSignTypedData=function(t){let{signTypedData:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("signTypedData",t),{signTypedData:i}},exports.useSignupWithPasskey=o=>{let s=e.useCaptcha(),{initSignupWithPasskey:n,signupWithPasskey:a,passkeyAuthState:l,setPasskeyAuthState:u}=i.usePrivyInternal();return{signupWithPasskey:r.useCallback((async()=>{try{let r;if(s.enabled&&"error"===s.status)throw new e.CaptchaError(s.error,null,t.PrivyErrorCode.CAPTCHA_FAILURE);s.enabled&&"success"!==s.status&&(s.execute(),r=await s.waitForResult()),await n({captchaToken:r,withPrivyUi:!1});let{user:i,isNewUser:l,wasAlreadyAuthenticated:u,loginAccount:c}=await a();o?.onComplete?.({user:i,isNewUser:l,wasAlreadyAuthenticated:u,loginMethod:"passkey",loginAccount:c})}catch(e){throw u({status:"error",error:e}),o?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR),e}}),[a,s.status]),state:l}},exports.useSubscribeToJwtAuthWithFlag=function({isAuthenticated:t,isLoading:i,...o}){let s=r.useRef();r.useEffect((()=>{i||s.current?.()}),[t,i]);let n=r.useCallback((e=>(s.current=e,()=>{s.current=void 0})),[]);return e.useSyncJwtBasedAuthState({...o,subscribe:n})},exports.useToken=function(t){let{getAccessToken:i}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("accessToken",t),{getAccessToken:i}},exports.useUpdateAccount=function(t){let{updateEmail:i,updatePhone:s}=r.useContext(o.PrivyContext);return e.usePrivyEventSubscription("update",t),{updateEmail:i,updatePhone:s}},exports.useUpdateEmail=s=>{let{user:n}=o.usePrivyContext(),{loginWithCode:a,emailOtpState:l,setEmailOtpState:u,client:c,inProgressAuthFlowRef:d,inProgressLoginOrLinkMethodRef:h}=i.usePrivyInternal();return{state:l,sendCode:r.useCallback((async({newEmailAddress:r})=>{try{if(!n?.email)throw Error("User is required to have an email address to update it.");let t=new e.UpdateEmailFlow(n.email.address,r);c.startAuthFlow(t),await t.sendCodeEmail({withPrivyUi:!1})}catch(r){u({status:"error",error:r}),s?.onError?.(r.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[n?.email]),verifyCode:r.useCallback((async({code:e})=>{try{if(!n?.email)throw Error("User is required to have an email address to update it.");d.current="update",h.current="email";let{user:r,linkedAccount:t}=await a(e);return s?.onSuccess?.({user:r,updateMethod:"email",updatedAccount:t}),{user:r}}catch(e){u({status:"error",error:e}),s?.onError?.(e.privyErrorCode||t.PrivyErrorCode.UNKNOWN_AUTH_ERROR,{linkMethod:"email"})}}),[n?.email])}},exports.useUser=()=>{let{setUser:e,client:t}=r.useContext(i.InternalPrivyContext),{user:s}=r.useContext(o.PrivyContext);return{user:s,refreshUser:r.useCallback((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}};
